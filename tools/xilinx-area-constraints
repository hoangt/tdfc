#!/usr/bin/perl
#
# xilinx-area-constraints
#
# Emit Xilinx ``.ucf'' area constraints file (to stdout)
#   for a minimum size, pseudo-square box around a given number of slices
# See ``minsquaremargin'' for definition of ``pseudo-square''
#
# Eylon Caspi, 2/26/05


$toolpathslash = ($0 =~ m{(.*/)}) ? $1 : "";


########  Subroutines  ########

sub usage {
  my $name = $0;
  $name =~ s{.*/}{};
  $namespaces = $name;
  $namespaces =~ s/./ /g;
  die
    "$name:  emit Xilinx area constraints (.ucf)\n" .
     $namespaces . "   for minimum pseudo-square box\n" .
    "Usage:  $name [-d device | -xy xsize ysize] [-m margin]\n" .
    "        " . $namespaces . " [-e expand] [-i instance] n\n" .
    "        device   = target device name        (default: none, no bound)\n".
    "        xsize    = max slices in x dimension   (>0, default: no bound)\n".
    "        ysize    = max slices in y dimension   (>0, default: no bound)\n".
    "        margin   = boundary slices to avoid, soft     (default: 0)\n" .
    "        expand   = expansion factor, multiplies n     (default: 1.0)\n" .
    "        instance = name of EDIF instance to constrain (default: *)\n".
    "        n        = number of LUT-FFs to fit (2 per slice)\n";
}

# sub fail {
#   my $prod = $xsize * $ysize;
#   die "Cannot fit $n into ($xsize x $ysize = $prod)\n";
# }

# sub succeed {
#   $x0=shift(@_);
#   $y0=shift(@_);
#   $x1=shift(@_);
#   $y1=shift(@_);
#   print "$x0 $y0 $x1 $y1\n";
#   exit;
# }


########  Cmd line  ########

$device="";	# - target device name         ("" = none)
$xsize=-1;	# - max slices in x dimension  (-1 = no bound)
$ysize=-1;	# - max slices in y dimension, (-1 = no bound)
$margin=0;	# - margin slices to avoid, soft
$expand="1.0";	# - expansion factor, multiplies n
$instance="*";	# - name of EDIF instance to constrain
$n=-1;		# - number of LUT-FFs to fit   (2 per slice)

if ($#ARGV<0) { usage(); }

while ($#ARGV >= 0) {
  $arg = shift(@ARGV);
  if    ($arg eq "-d")  { $device  =shift(@ARGV); }
  elsif ($arg eq "-xy") { $xsize   =shift(@ARGV); $ysize=shift(@ARGV); }
  elsif ($arg eq "-m")  { $margin  =shift(@ARGV); }
  elsif ($arg eq "-e")  { $expand  =shift(@ARGV); }
  elsif ($arg eq "-i")  { $instance=shift(@ARGV); }
  elsif ($arg =~ /^-/)  { usage(); }
  else                  { $n=$arg; }
}

if ($xsize==0 || $ysize==0 || $margin<0 || $expand<1.0 || $n<0) { usage(); }
if ($instance eq "")                                            { usage(); }

# print "device=$device xsize=$xsize ysize=$ysize margin=$margin expand=$expand instance=$instance n=$n\n";


#########  Get Device Size  ########

if ($device ne "") {
  $cmd = "${toolpathslash}device_slices $device";
  # print "cmd=$cmd\n";
  $device_slices = `$cmd`;
  if ($device_slices =~ /(\d+) (\d+)/) {
    # - Note, device_slices prints ``Y X''
    $ysize=$1;
    $xsize=$2;
    # print "device=$device --> xsize=$xsize ysize=$ysize\n"
  }
  else {
    die "Cannot determine size of device $device\n";
  }
}


########  Compute Box  ########

$xystr  = ($xsize >=0) ? "-xy $xsize $ysize" : "";
$mstr   = ($margin>=0) ? "-m $margin" : "";
$slices = int((($n * $expand)+1)/2);
$cmd    = "${toolpathslash}minsquaremargin " . $xystr . " " . $mstr .
          " $slices 2>/dev/null";
# print "cmd=$cmd\n";
$minsquaremargin = `$cmd`;
# print "minsquaremargin=$minsquaremargin\n";
if ($minsquaremargin =~ /(\d+) (\d+) (\d+) (\d+)/) {
  $x0=$1;  $y0=$2;  $x1=$3;  $y1=$4;
  # print "x0=$x0 y0=$y0 x1=$x1 y1=$y1\n";
}
else {
  my $prod = $xsize * $ysize;
  die "Cannot fit $slices into ($xsize x $ysize = $prod)\n";
}

########  Emit Constraints  ########

$xside     =  $x1-$x0+1;
$yside     =  $y1-$y0+1;
$devslices =  $xsize*$ysize;

printf("# Area constraints for a minimum pseudo-square box containing\n");
printf("#      $expand * $n LUTS = $slices slices\n");
printf(($xsize>=0) ? 
       "# Device $device = $xsize x $ysize = $devslices slices\n" :
       "# Device unspecified\n");
printf("# Box = (%d,%d)..(%d,%d) = %d x %d = %d slices.\n",
       $x0, $y0, $x1, $y1, $xside, $yside, $xside*$yside);
printf("# Generated by xilinx-area-constraints, " . `date` . "\n");
printf("INST \"$instance\" AREA_GROUP = \"area_group\" ;\n");
printf("AREA_GROUP \"area_group\" RANGE = SLICE_X%dY%d:SLICE_X%dY%d ;\n\n",
       $x0, $y0, $x1, $y1);
